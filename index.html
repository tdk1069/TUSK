<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MUD World Builder Pro v8.6</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        :root { --bg: #0f0f0f; --panel: #1a1a1a; --accent: #4a90e2; --text: #e0e0e0; --border: #333; --danger: #c0392b; --success: #27ae60; --modal-bg: #222; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; overflow: hidden; }
        
        /* Sidebar */
        #sidebar { width: 380px; background: var(--panel); border-right: 1px solid var(--border); display: flex; flex-direction: column; z-index: 10; }
        .tabs { display: flex; background: #111; border-bottom: 1px solid var(--border); }
        .tab-btn { flex: 1; padding: 10px 5px; border: none; background: none; color: #777; cursor: pointer; font-size: 0.75rem; font-weight: bold; text-transform: uppercase; border-bottom: 2px solid transparent; }
        .tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); background: #1a1a1a; }
        .tab-content { padding: 15px; flex-grow: 1; overflow-y: auto; display: none; }
        .tab-content.active { display: block; }

        /* General UI */
        label { display: block; font-size: 0.7rem; color: #888; margin-bottom: 4px; text-transform: uppercase; font-weight: 700; margin-top: 10px; }
        input, textarea, select { width: 100%; background: #000; color: #fff; border: 1px solid #444; padding: 8px; box-sizing: border-box; margin-bottom: 5px; border-radius: 4px; font-family: inherit; }
        button.action-btn { width:100%; padding: 8px; border:none; border-radius:4px; color:white; cursor:pointer; font-weight:bold; margin-top:5px; }
        .btn-green { background: var(--success); }
        .btn-blue { background: var(--accent); }
        .btn-red { background: var(--danger); }
        .btn-grey { background: #444; }
        .btn-sm { padding: 2px 8px; font-size: 0.75rem; width: auto; margin:0; }

        /* Lists */
        .list-item { background: #222; padding: 8px; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        .list-item:hover { background: #2a2a2a; }
        .list-item h4 { margin: 0; font-size: 0.9rem; color: #fff; pointer-events: none; }
        .list-item span { font-size: 0.75rem; color: #888; pointer-events: none; }
        
        /* Exits List */
        .exit-row { display: flex; justify-content: space-between; align-items: center; padding: 6px; background: #252525; border-bottom: 1px solid #333; font-size: 0.85rem; }
        .exit-dir { font-weight: bold; color: var(--accent); width: 40px; }
        .exit-dest { flex-grow: 1; color: #aaa; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding: 0 5px; }
        
        /* Modal */
        #modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000; justify-content: center; align-items: center; backdrop-filter: blur(3px); }
        #modal-box { background: var(--modal-bg); width: 500px; max-height: 90vh; border: 1px solid #444; border-radius: 6px; display: flex; flex-direction: column; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
        #modal-header { padding: 15px; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center; background: #1a1a1a; }
        #modal-body { padding: 20px; overflow-y: auto; }
        #modal-footer { padding: 15px; border-top: 1px solid #333; display: flex; justify-content: flex-end; gap: 10px; background: #1a1a1a; }

        /* Alignment Slider */
        .align-container { background: #111; padding: 10px; border-radius: 4px; text-align: center; margin-bottom: 10px; border: 1px solid #333; }
        .align-val { color: var(--accent); font-weight: bold; font-size: 1.1rem; display: block; margin-bottom: 5px; }

        /* Tooltip */
        .help-tip {
            display: inline-block; cursor: help; color: var(--accent);
            font-size: 0.7rem; margin-left: 6px; border: 1px solid var(--accent);
            width: 14px; height: 14px; line-height: 14px; text-align: center; border-radius: 50%;
            position: relative; font-weight: bold;
        }
        .help-tip:hover::after {
            content: attr(data-tip);
            position: absolute; left: 20px; top: -5px; width: 220px;
            background: #252525; color: #eee; padding: 8px; border: 1px solid #555;
            z-index: 100; font-size: 0.75rem; border-radius: 4px; pointer-events: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); font-weight: normal; line-height: 1.3;
        }

        /* Map */
        #canvas-container { flex-grow: 1; position: relative; }
        canvas { display: block; }
        #compass-overlay { position: absolute; top: 20px; left: 400px; background: rgba(26,26,26,0.8); padding: 10px; border-radius: 8px; border: 1px solid var(--border); backdrop-filter: blur(4px); z-index: 5; }
        .compass-grid { display: grid; grid-template-columns: repeat(3, 35px); gap: 5px; }
        .dir-btn { width: 35px; height: 35px; background: #333; border: 1px solid #444; color: #fff; cursor: pointer; border-radius: 4px; font-size: 11px; font-weight: bold; }
        .dir-btn:hover { background: var(--accent); }
        .z-btns { display: flex; gap: 5px; margin-top: 8px; }
        .z-btn { flex: 1; padding: 5px; font-size: 10px; background: #222; border: 1px solid #444; color: white; cursor: pointer; }
    </style>
</head>
<body>

<div id="modal-overlay">
    <div id="modal-box">
        <div id="modal-header">
            <h3 id="modal-title" style="margin:0">Edit</h3>
            <button onclick="closeModal()" style="background:none; border:none; color:#888; cursor:pointer; font-size:1.2rem;">&times;</button>
        </div>
        <div id="modal-body"></div>
        <div id="modal-footer">
            <button class="action-btn btn-grey" style="width:auto" onclick="closeModal()">Cancel</button>
            <button class="action-btn btn-green" style="width:auto" onclick="saveModal()">Save Changes</button>
        </div>
    </div>
</div>

<div id="compass-overlay">
    <div class="compass-grid">
        <button class="dir-btn" onclick="dig('nw')">NW</button>
        <button class="dir-btn" onclick="dig('n')">N</button>
        <button class="dir-btn" onclick="dig('ne')">NE</button>
        <button class="dir-btn" onclick="dig('w')">W</button>
        <div style="text-align:center; line-height:35px; color:#555">┼</div>
        <button class="dir-btn" onclick="dig('e')">E</button>
        <button class="dir-btn" onclick="dig('sw')">SW</button>
        <button class="dir-btn" onclick="dig('s')">S</button>
        <button class="dir-btn" onclick="dig('se')">SE</button>
    </div>
    <div class="z-btns">
        <button class="z-btn" onclick="dig('up')">UP ▲</button>
        <button class="z-btn" onclick="dig('down')">DWN ▼</button>
    </div>
</div>

<div id="sidebar">
    <div class="tabs">
        <button class="tab-btn active" onclick="showTab('basic')">Room</button>
        <button class="tab-btn" onclick="showTab('objects')">Obj</button>
        <button class="tab-btn" onclick="showTab('monsters')">Mon</button>
        <button class="tab-btn" onclick="showTab('file')">File</button>
    </div>

    <div id="tab-basic" class="tab-content active">
        <h3>Current Room</h3>
        <label>Room Name</label>
        <input type="text" id="r-name" oninput="syncRoom()">
        <label>Room Description</label>
        <textarea id="r-long" rows="8" oninput="syncRoom()"></textarea>
        
        <label>Terrain</label>
        <select id="r-terrain" onchange="syncRoom()">
            <option value="forest">Forest</option>
            <option value="plains">Plains</option>
            <option value="hills">Hills</option>
            <option value="mountains">Mountains</option>
            <option value="town">Town</option>
            <option value="coast">Coast</option>
            <option value="sea">Sea</option>
            <option value="swamp">Swamp</option>
            <option value="jungle">Jungle</option>
            <option value="underwater">Underwater</option>
            <option value="desert">Desert</option>
            <option value="river">River</option>
            <option value="tundra">Tundra</option>
            <option value="snowplains">Snowplains</option>
            <option value="treetops">Treetops</option>
            <option value="lake">Lake</option>
            <option value="indoor">Indoor</option>
        </select>

        <hr>
        <h3>Exits & Doors</h3>
        <div id="exit-list"></div>

        <hr>
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h3>Senses & Details</h3>
            <button class="action-btn btn-blue" style="width:auto; padding:5px 10px;" onclick="openDetailModal(-1)">+ Add</button>
        </div>
        <div id="detail-list" style="margin-top:10px;"></div>

        <hr>
        <div style="display:flex; gap:10px; margin-top:20px;">
            <button class="action-btn btn-grey" onclick="openCommentModal()">Add Room Comment</button>
            <button class="action-btn btn-red" onclick="deleteRoom()">Delete Room</button>
        </div>
    </div>

    <div id="tab-objects" class="tab-content">
        <h3>Room Contents</h3>
        <div style="display:flex; gap:5px; margin-bottom:10px;">
            <select id="room-obj-select"></select>
            <button class="dir-btn" onclick="addObjToRoom()">+</button>
        </div>
        <div id="room-obj-list"></div>
        <hr>
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h3>Object Library</h3>
            <button class="action-btn btn-blue" style="width:auto; padding:5px 10px;" onclick="openObjectModal(-1)">+ New</button>
        </div>
        <div id="global-obj-list" style="margin-top:10px;"></div>
    </div>

    <div id="tab-monsters" class="tab-content">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h3>Monsters in Room</h3>
            <button class="action-btn btn-blue" style="width:auto; padding:5px 10px;" onclick="openMonsterModal(-1)">+ New</button>
        </div>
        <div id="monster-list" style="margin-top:15px;"></div>
    </div>

    <div id="tab-file" class="tab-content">
        <h3>Project Files</h3>
        <button class="action-btn btn-grey" onclick="downloadJSON()">Save Project (JSON)</button>
        <button class="action-btn btn-grey" onclick="importData()">Load Project (JSON)</button>
        <hr>
        <h3>LPC Export Settings</h3>
        <label>Area Name</label> <input type="text" id="area-name" value="new_area" oninput="exportSettings.areaName=this.value">
        <label>Base Path</label> <input type="text" id="base-path" value="/d/domain/new_area/" oninput="exportSettings.basePath=this.value">
        <label>Base Level</label> <input type="number" id="base-level" value="5" oninput="exportSettings.baseLevel=this.value">
        <button class="action-btn btn-red" style="margin-top:15px;" onclick="exportLPC()">Export .zip (LPC)</button>
    </div>
</div>

<div id="canvas-container">
    <canvas id="mapCanvas"></canvas>
</div>

<script>
    /* --- CONFIG & HELPERS --- */
    const VALID_WEAPON_TYPES = ["blade", "knife", "projectile", "blunt", "two handed", "polearm", "staff", "whip", "thrown"];
    const VALID_ARMOUR_TYPES = ["helmet", "armour", "cloak", "shield", "gloves", "ring", "boots", "amulet", "barding", "necklace", "circlet", "bracelet", "anklet"];
    const VALID_MATERIALS = ["cloth", "leather", "mail", "plate"];
    const ALIGN_MAP = { 1250: "SAINTLY", 1000: "RIGHTEOUS", 750: "GOOD", 500: "BENEVOLENT", 250: "NICE", 0: "NEUTRAL", "-250": "MEAN", "-500": "MALEVOLENT", "-750": "EVIL", "-1000": "NEFARIOUS", "-1250": "DEMONIC" };
    const ALIGN_KEYS = Object.keys(ALIGN_MAP).map(Number).sort((a,b) => a - b); 

    function getAlignLabel(val) {
        val = parseInt(val);
        let closest = ALIGN_KEYS.reduce((prev, curr) => Math.abs(curr - val) < Math.abs(prev - val) ? curr : prev);
        return ALIGN_MAP[closest];
    }
    
    function makeTip(text) { return `<span class="help-tip" data-tip="${text}">?</span>`; }

    /* --- STRING WRAPPING LOGIC (FIX) --- */
    function formatLPC(fnName, text, indentLevel = 1) {
        if (!text) return "";
        const indent = "    ".repeat(indentLevel);
        
        // Split by whitespace but preserve meaningful word blocks
        const words = text.replace(/[\r\n]+/g, ' ').trim().split(/\s+/);
        let lines = [];
        let currentLine = "";

        words.forEach(word => {
            // Check if adding the word exceeds limit (70 chars safe zone)
            if (currentLine.length + word.length + 1 > 70) {
                lines.push(currentLine); // Push line with trailing space
                currentLine = word + " ";
            } else {
                currentLine += word + " ";
            }
        });
        // Push the last partial line, trimming the trailing space for the very end
        if (currentLine.trim().length > 0) lines.push(currentLine);

        // Single line case
        if (lines.length === 0) return `${indent}${fnName}("");`;
        if (lines.length === 1) return `${indent}${fnName}("${lines[0].trim()}");`;

        // Multi-line case
        // We ensure spaces are kept inside the quotes for intermediate lines
        const formattedLines = lines.map((line, i) => {
            const isFirst = i === 0;
            const isLast = i === lines.length - 1;
            const content = isLast ? line.trim() : line; // Keep trailing space for non-last lines
            const prefix = isFirst ? `"` : `${indent}  "`;
            const suffix = isLast ? `");` : `"`;
            return prefix + content + suffix;
        }).join('\n');

        return `${indent}${fnName}(${formattedLines}`;
    }

    /* --- STATE --- */
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');
    let rooms = [];
    let links = [];
    let objectLibrary = [];
    let activeRoom = null;
    let currentZ = 0;
    let camera = { x: 0, y: 0 };
    let isPanning = false, lastMouse = { x: 0, y: 0 };
    let exportSettings = { areaName: "new_area", basePath: "/d/domain/new_area/", baseLevel: 5 };
    
    // Modal Context
    let currentEditType = null, currentEditId = null, currentEditLink = null; 

    /* --- DIGGING (GLOBAL SCOPE) --- */
    window.dig = function(dir) {
        if(!activeRoom) return;
        let tx = activeRoom.x, ty = activeRoom.y, tz = activeRoom.z;
        const G = 60;
        switch(dir) {
            case 'n': ty -= G; break; case 's': ty += G; break;
            case 'e': tx += G; break; case 'w': tx -= G; break;
            case 'ne': tx+=G; ty-=G; break; case 'nw': tx-=G; ty-=G; break;
            case 'se': tx+=G; ty+=G; break; case 'sw': tx-=G; ty+=G; break;
            case 'up': tz++; break; case 'down': tz--; break;
        }
        let target = rooms.find(r => r.x==tx && r.y==ty && r.z==tz);
        if(!target) target = createRoom(tx, ty, tz, "New Room");
        if(!links.find(l => (l.from==activeRoom.id && l.to==target.id) || (l.from==target.id && l.to==activeRoom.id))) {
            links.push({from:activeRoom.id, to:target.id, door: {active:false}});
        }
        activeRoom = target; currentZ = tz;
        syncUI();
    };

    function deleteRoom() {
        if(!activeRoom || rooms.length<=1 || !confirm("Delete Room?")) return;
        links = links.filter(l => l.from!==activeRoom.id && l.to!==activeRoom.id);
        rooms = rooms.filter(r => r.id!==activeRoom.id);
        activeRoom = rooms[0]; currentZ=activeRoom.z;
        syncUI();
    }

    function createRoom(x, y, z, name) {
        const r = { id: Date.now()+Math.random(), x, y, z, name, longDesc: "A generic room.", terrain: "indoor", comments: "", details: [], monsters: [], objects: [] };
        rooms.push(r);
        return r;
    }

    /* --- INITIALIZATION --- */
    function init() {
        window.addEventListener('resize', resize);
        canvas.addEventListener('mousedown', onDown);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', () => isPanning = false);
        activeRoom = createRoom(0, 0, 0, "The Start");
        createObjectDef("sword", "a rusty sword", "weapon", "blade");
        setTimeout(() => { resize(); syncUI(); draw(); }, 100);
    }
    
    function syncUI() {
        if(!activeRoom) return;
        document.getElementById('r-name').value = activeRoom.name;
        document.getElementById('r-long').value = activeRoom.longDesc;
        document.getElementById('r-terrain').value = activeRoom.terrain;
        refreshLists(); draw();
    }

    /* --- UI UPDATES & MODALS --- */
    function showTab(tabId) {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        event.target.classList.add('active');
        document.getElementById('tab-' + tabId).classList.add('active');
        refreshLists();
    }

    function refreshLists() {
        if(!activeRoom) return;
        // Exit List 
        const exitList = document.getElementById('exit-list');
        let myLinks = links.filter(l => l.from === activeRoom.id || l.to === activeRoom.id);
        let html = "";
        
        const getDir = (r1, r2) => {
            if(r2.z > r1.z) return "Up"; if(r2.z < r1.z) return "Down";
            if(r2.y < r1.y) { if(r2.x < r1.x) return "NW"; if(r2.x > r1.x) return "NE"; return "North"; }
            if(r2.y > r1.y) { if(r2.x < r1.x) return "SW"; if(r2.x > r1.x) return "SE"; return "South"; }
            return r2.x > r1.x ? "East" : "West";
        };

        myLinks.forEach(l => {
            let otherId = l.from === activeRoom.id ? l.to : l.from;
            let other = rooms.find(r => r.id === otherId);
            if(!other) return;
            let dir = getDir(activeRoom, other);
            let hasDoor = l.door && l.door.active;
            html += `<div class="exit-row"><span class="exit-dir">${dir}</span><span class="exit-dest">${other.name}</span><button class="btn-sm ${hasDoor?"btn-blue":"btn-grey"}" onclick="openDoorModal('${l.from}','${l.to}')">${hasDoor?"Door (Edit)":"Door (None)"}</button></div>`;
        });
        if(html === "") html = "<div style='padding:10px; color:#666; font-size:0.8rem; text-align:center'>No exits. Use the compass to dig.</div>";
        exitList.innerHTML = html;

        // Detail List
        document.getElementById('detail-list').innerHTML = activeRoom.details.map((d,i) => 
            `<div class="list-item" onclick="openDetailModal(${i})"><div style="overflow:hidden; max-width:220px;"><span style="color:var(--accent); font-weight:bold; margin-right:5px; font-size:0.7rem;">[${d.type.toUpperCase()}]</span><h4 style="display:inline">${d.keywords}</h4></div><button class="btn-red btn-sm" onclick="event.stopPropagation(); activeRoom.details.splice(${i},1);refreshLists()">X</button></div>`
        ).join('');

        // Standard Lists
        document.getElementById('room-obj-list').innerHTML = activeRoom.objects.map((oid,i) => {
            const o = objectLibrary.find(x=>x.id==oid);
            return o ? `<div class="list-item"><span>${o.short}</span><button class="btn-red btn-sm" onclick="activeRoom.objects.splice(${i},1);refreshLists()">X</button></div>` : '';
        }).join('');
        document.getElementById('room-obj-select').innerHTML = objectLibrary.map(o => `<option value="${o.id}">${o.short}</option>`).join('');
        document.getElementById('global-obj-list').innerHTML = objectLibrary.map((o,i) => `<div class="list-item" onclick="openObjectModal(${i})"><div><h4>${o.idName}</h4><span>${o.type}</span></div><button class="btn-red btn-sm" onclick="event.stopPropagation(); objectLibrary.splice(${i},1); refreshLists();">X</button></div>`).join('');
        document.getElementById('monster-list').innerHTML = activeRoom.monsters.map((m,i) => `<div class="list-item" onclick="openMonsterModal(${i})"><div><h4>${m.short}</h4><span>Lvl Adj: ${m.levelAdj||0} ${m.race}</span></div><button class="btn-red btn-sm" onclick="event.stopPropagation(); activeRoom.monsters.splice(${i},1); refreshLists();">X</button></div>`).join('');
    }

    function syncRoom() { activeRoom.name = document.getElementById('r-name').value; activeRoom.longDesc = document.getElementById('r-long').value; activeRoom.terrain = document.getElementById('r-terrain').value; draw(); }
    
    /* --- MODALS --- */
    function openModal(title) { document.getElementById('modal-overlay').style.display = 'flex'; document.getElementById('modal-title').innerText = title; }
    function closeModal() { document.getElementById('modal-overlay').style.display = 'none'; refreshLists(); draw(); }
    function saveModal() { closeModal(); }

    function openCommentModal() {
        currentEditType = 'comment'; openModal("Room Comments");
        document.getElementById('modal-body').innerHTML = `<p style="color:#888; font-size:0.8rem;">Comments for top of file.</p><textarea rows="10" oninput="activeRoom.comments = this.value">${activeRoom.comments}</textarea>`;
    }

    function openDoorModal(fromId, toId) {
        currentEditLink = links.find(l => (l.from == fromId && l.to == toId));
        if(!currentEditLink.door) currentEditLink.door = { active: false, id: "door", state: "closed", key: "" };
        const d = currentEditLink.door; openModal("Edit Door");
        document.getElementById('modal-body').innerHTML = `
            <label>Has Door?</label><select id="door-active" onchange="updateDoor('active', this.value === 'true')"><option value="false" ${!d.active?'selected':''}>No</option><option value="true" ${d.active?'selected':''}>Yes</option></select>
            <div id="door-opts" style="display:${d.active?'block':'none'}"><label>Door ID</label><input type="text" value="${d.id}" oninput="updateDoor('id', this.value)"><label>State</label><select onchange="updateDoor('state', this.value)"><option value="open" ${d.state==='open'?'selected':''}>Open</option><option value="closed" ${d.state==='closed'?'selected':''}>Closed</option><option value="locked" ${d.state==='locked'?'selected':''}>Locked</option></select><label>Key ID</label><input type="text" value="${d.key}" oninput="updateDoor('key', this.value)"></div>`;
    }
    function updateDoor(key, val) { currentEditLink.door[key] = val; if(key === 'active') document.getElementById('door-opts').style.display = val ? 'block' : 'none'; }

    function openDetailModal(idx) {
        currentEditType = 'detail'; currentEditId = idx;
        if(idx === -1) { activeRoom.details.push({ type: "look", keywords: "default", desc: "It reads: Beware." }); currentEditId = activeRoom.details.length - 1; }
        const d = activeRoom.details[currentEditId]; openModal("Edit Detail / Sense");
        document.getElementById('modal-body').innerHTML = `
            <label>Type</label><select onchange="activeRoom.details[currentEditId].type = this.value"><option value="look" ${d.type==='look'?'selected':''}>Look (Item)</option><option value="listen" ${d.type==='listen'?'selected':''}>Listen (Sound)</option><option value="smell" ${d.type==='smell'?'selected':''}>Smell (Scent)</option></select>
            <label>Keywords</label><input type="text" value="${d.keywords}" oninput="activeRoom.details[currentEditId].keywords = this.value"><label>Description</label><textarea rows="6" oninput="activeRoom.details[currentEditId].desc = this.value">${d.desc}</textarea>`;
    }

    function openMonsterModal(idx) {
        currentEditType = 'monster'; currentEditId = idx;
        if(idx === -1) { activeRoom.monsters.push({ id: Date.now(), idName: "guard", short: "a guard", long: "A guard.", race: "Human", class: "Fighter", levelAdj: 0, gender: "neuter", alignment: 0, inventory: [] }); currentEditId = activeRoom.monsters.length - 1; }
        const m = activeRoom.monsters[currentEditId]; if(m.levelAdj === undefined) m.levelAdj = 0;
        openModal("Edit Monster");
        const invOpts = objectLibrary.map(o => `<option value="${o.id}">${o.short}</option>`).join('');
        let invList = m.inventory.map((oid, i) => { const o = objectLibrary.find(x=>x.id==oid); return o ? `<span style="background:#333; padding:2px 6px; border-radius:3px; margin-right:5px; font-size:0.8rem; border:1px solid #555;">${o.short} <span style="color:#c0392b; cursor:pointer;" onclick="removeMonInv(${i})">x</span></span>` : ''; }).join('');
        const alignLabel = getAlignLabel(m.alignment);
        document.getElementById('modal-body').innerHTML = `
            <div style="display:flex; gap:10px;"><div style="flex:1"><label>ID Name</label><input type="text" value="${m.idName}" oninput="updateMon('idName', this.value)"></div><div style="flex:1"><label>Short Desc</label><input type="text" value="${m.short}" oninput="updateMon('short', this.value)"></div></div>
            <div style="display:flex; gap:10px;"><div style="flex:1"><label>Lvl Adj</label><input type="number" value="${m.levelAdj}" oninput="updateMon('levelAdj', this.value)"></div><div style="flex:1"><label>Race</label><select onchange="updateMon('race',this.value)">${['Arachnid','Artrell','Aurin','Basilisk','Bat','Bee','Beetle','Beholder','Bird','Carrion-crawler','Centaur','Centipede','Chimera','Cockatrice','Crocodile','Crustacean','Dagon','Drider','Drow','Dwarf','Elf','Equine','Equine-winged','Faerie','Fish','Frog','Giant','Gnome','Half-Elf','Halfling','Half-Orc','Human','Humanoid-tail','Insectoid','nsectoid-winged','Lizardman','Merperson','Null','Nymph','Octopus','Otyugh','Quadruped','Quadruped-winged','Ray','Reptile','Reptile-winged','Satyr','Slime','Snakeman','Snae-winged','Turtle','Worm'].map(r=>`<option ${m.race===r?'selected':''}>${r}</option>`)}</select></div><div style="flex:1"><label>Class</label><select onchange="updateMon('class',this.value)">${['None','Fighter','Warmage','Cleric','Rogue','Druid','Monk','Ranger'].map(c=>`<option ${m.class===c?'selected':''}>${c}</option>`)}</select></div></div>
            <div class="align-container" style="margin-top:10px;"><label>Alignment</label><span id="align-lbl" class="align-val">${alignLabel} (${m.alignment})</span><input type="range" min="-1250" max="1250" step="50" value="${m.alignment}" oninput="updateAlignUI(this.value)"></div>
            <label>Inventory</label><div style="display:flex; gap:5px;"><select id="mon-inv-sel">${invOpts}</select><button class="dir-btn" onclick="addMonInv()">+</button></div><div style="margin-bottom:10px;">${invList}</div><label>Long Description</label><textarea rows="3" oninput="updateMon('long', this.value)">${m.long}</textarea>`;
    }
    
    function updateAlignUI(val) { val = parseInt(val); activeRoom.monsters[currentEditId].alignment = val; document.getElementById('align-lbl').innerText = `${getAlignLabel(val)} (${val})`; }
    function updateMon(k,v) { activeRoom.monsters[currentEditId][k]=v; }
    function addMonInv() { const v=document.getElementById('mon-inv-sel').value; if(v){ activeRoom.monsters[currentEditId].inventory.push(v); openMonsterModal(currentEditId); } }
    function removeMonInv(i) { activeRoom.monsters[currentEditId].inventory.splice(i,1); openMonsterModal(currentEditId); }

    function openObjectModal(idx) {
        currentEditType = 'object'; currentEditId = idx;
        if(idx === -1) { createObjectDef("item", "a new item", "simple", ""); currentEditId = objectLibrary.length - 1; }
        const obj = objectLibrary[currentEditId]; if(obj.levelAdj === undefined) obj.levelAdj = 0; if(obj.keyId === undefined) obj.keyId = "";
        openModal("Edit Object");
        let typeSelect = `<input disabled style="background:#222; border:none;" placeholder="N/A">`;
        if(obj.type === 'weapon') typeSelect = `<select onchange="updateObj('subtype', this.value)">${VALID_WEAPON_TYPES.map(t=>`<option ${obj.subtype===t?'selected':''}>${t}</option>`)}</select>`;
        else if(obj.type === 'armour') typeSelect = `<select onchange="updateObj('subtype', this.value)">${VALID_ARMOUR_TYPES.map(t=>`<option ${obj.subtype===t?'selected':''}>${t}</option>`)}</select>`;
        let matSelect = (obj.type === 'armour') ? `<div style="flex:1"><label>Material</label><select onchange="updateObj('material', this.value)">${VALID_MATERIALS.map(t=>`<option ${obj.material===t?'selected':''}>${t}</option>`)}</select></div>` : "";
        let keyUI = (obj.type === 'key') ? `<div style="background:#222; padding:10px; border:1px solid #444; margin-bottom:10px;"><label>Lock Match ID</label><input type="text" value="${obj.keyId}" oninput="updateObj('keyId', this.value)"></div>` : "";
        document.getElementById('modal-body').innerHTML = `
            <div style="display:flex; gap:10px;"><div style="flex:1"><label>ID</label><input type="text" value="${obj.idName}" oninput="updateObj('idName', this.value)"></div><div style="flex:1"><label>Short</label><input type="text" value="${obj.short}" oninput="updateObj('short', this.value)"></div></div>
            ${keyUI}<div style="display:flex; gap:10px;"><div style="flex:1"><label>Category</label><select onchange="updateObj('type', this.value); openObjectModal(currentEditId)"><option value="simple" ${obj.type==='simple'?'selected':''}>Simple</option><option value="key" ${obj.type==='key'?'selected':''}>Key</option><option value="weapon" ${obj.type==='weapon'?'selected':''}>Weapon</option><option value="armour" ${obj.type==='armour'?'selected':''}>Armour</option></select></div><div style="flex:1"><label>Type</label>${typeSelect}</div>${matSelect}</div>
            <div style="display:flex; gap:10px;"><div style="flex:1"><label>Lvl Adj</label><input type="number" value="${obj.levelAdj}" oninput="updateObj('levelAdj', this.value)"></div></div><label>Long Desc</label><textarea rows="4" oninput="updateObj('long', this.value)">${obj.long}</textarea>`;
    }
    
    function createObjectDef(idName, short, type, subtype) { objectLibrary.push({ id: Date.now()+Math.random(), idName, short, long: `It is ${short}.`, type, subtype, material: "plate", levelAdj: 0, keyId: "" }); }
    function updateObj(k,v) { objectLibrary[currentEditId][k] = v; if(k==='type') { if(v==='weapon') objectLibrary[currentEditId].subtype="blade"; if(v==='armour') { objectLibrary[currentEditId].subtype="helmet"; objectLibrary[currentEditId].material="plate"; } else objectLibrary[currentEditId].subtype=""; } }
    function addObjToRoom() { const v=document.getElementById('room-obj-select').value; if(v){activeRoom.objects.push(v); refreshLists(); draw();} }

    /* --- MAP DRAWING --- */
    function draw() {
        if (!activeRoom || !canvas.width) return;
        ctx.save(); ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.translate(canvas.width/2 + camera.x, canvas.height/2 + camera.y);
        links.forEach(l => {
            const r1 = rooms.find(r => r.id === l.from), r2 = rooms.find(r => r.id === l.to);
            if(!r1 || !r2 || r1.z !== currentZ || r2.z !== currentZ) return;
            ctx.beginPath(); ctx.strokeStyle = '#444'; ctx.lineWidth = 2; ctx.moveTo(r1.x + 17, r1.y + 17); ctx.lineTo(r2.x + 17, r2.y + 17); ctx.stroke();
            if(l.door && l.door.active) { const mx = (r1.x + r2.x)/2 + 17, my = (r1.y + r2.y)/2 + 17; ctx.fillStyle = '#c0392b'; ctx.fillRect(mx-4, my-4, 8, 8); }
        });
        rooms.forEach(r => {
            if(r.z !== currentZ) return;
            ctx.fillStyle = (r === activeRoom) ? '#e67e22' : '#2c3e50'; ctx.fillRect(r.x, r.y, 35, 35);
            ctx.strokeStyle = (r === activeRoom) ? '#fff' : '#555'; ctx.strokeRect(r.x, r.y, 35, 35);
            let hasUp=false, hasDown=false; links.forEach(l => { let otherId = (l.from===r.id)?l.to:(l.to===r.id?l.from:null); if(otherId) { let o = rooms.find(x=>x.id===otherId); if(o && o.z>r.z) hasUp=true; if(o && o.z<r.z) hasDown=true; } });
            if(hasUp) { ctx.fillStyle="#fff"; ctx.beginPath(); ctx.moveTo(r.x+25,r.y+5); ctx.lineTo(r.x+30,r.y+12); ctx.lineTo(r.x+20,r.y+12); ctx.fill(); }
            if(hasDown){ ctx.fillStyle="#fff"; ctx.beginPath(); ctx.moveTo(r.x+25,r.y+30); ctx.lineTo(r.x+30,r.y+23); ctx.lineTo(r.x+20,r.y+23); ctx.fill(); }
            if(r.monsters.length) { ctx.fillStyle="#8e44ad"; ctx.beginPath(); ctx.arc(r.x+35,r.y,5,0,6.28); ctx.fill(); }
            if(r.objects.length) { ctx.fillStyle="#27ae60"; ctx.beginPath(); ctx.arc(r.x+35,r.y+35,5,0,6.28); ctx.fill(); }
            if(r.details.length) { ctx.fillStyle="#3498db"; ctx.beginPath(); ctx.arc(r.x,r.y+35,5,0,6.28); ctx.fill(); }
        });
        ctx.restore();
    }
    
    function onDown(e) { const r = canvas.getBoundingClientRect(), mx = e.clientX - r.left - (canvas.width/2 + camera.x), my = e.clientY - r.top - (canvas.height/2 + camera.y); const clicked = rooms.find(rm => mx>rm.x && mx<rm.x+35 && my>rm.y && my<rm.y+35 && rm.z==currentZ); if(clicked) { activeRoom = clicked; syncUI(); } else { isPanning = true; lastMouse = {x:e.clientX, y:e.clientY}; } }
    function onMove(e) { if(isPanning) { camera.x += e.clientX - lastMouse.x; camera.y += e.clientY - lastMouse.y; lastMouse = {x:e.clientX, y:e.clientY}; draw(); } }
    function resize() { canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight; draw(); }

    /* --- EXPORT GENERATION --- */
    function makeSafe(s) { return s.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '') || "unk"; }
    function getLevelStr(adj) { adj = parseInt(adj) || 0; if(adj === 0) return "BASE_LEVEL"; return adj > 0 ? `BASE_LEVEL+${adj}` : `BASE_LEVEL${adj}`; }

    // --- ASCII MAP GENERATOR ---
    function generateASCIIMap(roomMap) {
        // Collect all Z levels
        const zLevels = [...new Set(rooms.map(r => r.z))].sort((a,b) => b - a); // Top down
        let output = "";
        const symbols = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789abcdefghijklmnopqrstuvwxyz";

        zLevels.forEach(z => {
            output += `\n=== LEVEL ${z} ===\n\n`;
            
            // Filter rooms on this level
            const floorRooms = rooms.filter(r => r.z === z);
            if(floorRooms.length === 0) return;

            // Normalize Coordinates
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            floorRooms.forEach(r => {
                if(r.x < minX) minX = r.x; if(r.y < minY) minY = r.y;
                if(r.x > maxX) maxX = r.x; if(r.y > maxY) maxY = r.y;
            });

            // Grid Logic: Rooms are 60 units apart.
            // X Step: 6 chars (3 for room [X], 3 for link ---)
            // Y Step: 3 lines (1 for room, 2 for vertical links/diagonals)
            const xOffset = Math.abs(minX);
            const yOffset = Math.abs(minY);
            
            // Calculate grid dimensions
            const gridW = Math.ceil((maxX - minX) / 60) + 1;
            const gridH = Math.ceil((maxY - minY) / 60) + 1;
            
            const charW = gridW * 6 + 1;
            const charH = gridH * 3 + 1;

            // Init Buffer
            let buffer = Array(charH).fill(null).map(() => Array(charW).fill(' '));

            // Place Rooms and Links
            floorRooms.forEach(r => {
                // Map to integer grid
                const gx = (r.x - minX) / 60;
                const gy = (r.y - minY) / 60;
                
                // Map to Text Buffer
                const tx = gx * 6;
                const ty = gy * 3;

                // Assign Symbol
                const roomName = makeSafe(r.name);
                let symbol = "*";
                // Simple hash for symbol consistency if < 60 rooms, else *
                const idx = floorRooms.indexOf(r);
                if(idx < symbols.length) symbol = symbols[idx];

                // Draw Room: [A]
                if(r.x === 0 && r.y === 0 && r.z === 0) {
                    buffer[ty][tx] = '['; buffer[ty][tx+1] = '+'; buffer[ty][tx+2] = ']'; // Start Room
                } else {
                    buffer[ty][tx] = '['; buffer[ty][tx+1] = symbol; buffer[ty][tx+2] = ']';
                }

                // Draw Exits
                links.forEach(l => {
                    let other = null;
                    if(l.from === r.id) other = rooms.find(x => x.id === l.to);
                    else if(l.to === r.id) other = rooms.find(x => x.id === l.from);
                    
                    if(other && other.z === z) {
                        // Determine relative position
                        const dx = (other.x - r.x) / 60;
                        const dy = (other.y - r.y) / 60;

                        if(dx === 1 && dy === 0) { // East
                            buffer[ty][tx+3] = '-'; buffer[ty][tx+4] = '-'; buffer[ty][tx+5] = '-';
                        }
                        else if(dx === 0 && dy === 1) { // South
                             buffer[ty+1][tx+1] = '|'; buffer[ty+2][tx+1] = '|';
                        }
                        else if(dx === 1 && dy === 1) { // SE
                             buffer[ty+1][tx+4] = '\\'; 
                        }
                        else if(dx === -1 && dy === 1) { // SW
                             buffer[ty+1][tx-2] = '/';
                        }
                    }
                });
            });

            // Flatten buffer to string
            output += buffer.map(row => row.join('')).join('\n') + "\n\n";

            // Legend
            output += "Legend:\n";
            if(floorRooms.some(r => r.x==0 && r.y==0 && r.z==0)) output += "  [+] Start Room (0,0,0)\n";
            floorRooms.forEach((r, i) => {
                let sym = (i < symbols.length) ? symbols[i] : "*";
                if(!(r.x===0 && r.y===0 && r.z===0)) {
                    const fname = roomMap[r.id];
                    output += `  [${sym}] ${r.name} (${fname})\n`;
                }
            });
            output += "--------------------------------------\n";
        });

        return output;
    }

    async function exportLPC() {
        const zip = new JSZip();
        const area = exportSettings.areaName || "area";
        const path = exportSettings.basePath.replace(/\/$/, '') + '/';
        const blvl = parseInt(exportSettings.baseLevel) || 5;
        
        const f = zip.folder(area);
        f.folder("include").file("include.h", `#include <std.h>\n#define MY_PATH "${path}"\n#define ROOMDIR MY_PATH+"rooms/"\n#define MONDIR MY_PATH+"mon/"\n#define OBJDIR MY_PATH+"obj/"\n#define BASE_LEVEL ${blvl}`);
        
        const objMap = {};
        objectLibrary.forEach(o => {
            const parts = o.idName.split(',').map(s => s.trim());
            const primeId = parts[0].toLowerCase();
            const allIds = parts.map(s => `"${s.toLowerCase()}"`);
            const fname = makeSafe(parts[0]) + ".c";
            objMap[o.id] = fname;
            allIds.push(`"${o.type}"`);
            let xtra = "";
            if(o.type==='key') xtra=`    set_key_id("${o.keyId || primeId}");`;
            if(o.type==='weapon') xtra=`    set_type("${o.subtype}");`;
            if(o.type==='armour') { 
                xtra = `    set_type("${o.subtype}");`;
                // Only add set_subtype (material) if the item is NOT a cloak
                if(o.subtype !== 'cloak') {
                    xtra += `\n    set_subtype("${o.material}");`;
                }
            }

            f.folder("obj").file(fname, `#include "../include/include.h"\ninherit ${o.type==='weapon'?'WEAPON':(o.type==='armour'?'ARMOUR':(o.type==='key'?'KEY':'OBJECT'))};\nvoid create() {\n    ::create();\n    set_name("${primeId}");\n    set_id(({${allIds.join(',')}}));\n${formatLPC("set_short", o.short)}\n${formatLPC("set_long", o.long)}\n    set_level(${getLevelStr(o.levelAdj)});\n${xtra}\n}`);
        });

        // Auto Keys
        const autoKeys = new Set();
        links.forEach(l => { if(l.door && l.door.active && l.door.key) { if(!objectLibrary.some(o => o.keyId === l.door.key)) autoKeys.add(l.door.key); } });
        autoKeys.forEach(k => { f.folder("obj").file(makeSafe(k)+".c", `#include "../include/include.h"\ninherit KEY;\nvoid create() {\n    ::create();\n    set_name("${k}");\n    set_id(({"${k}", "key"}));\n    set_key_id("${k}");\n    set_short("a ${k}");\n    set_long("It is a ${k}, used to unlock something.");\n    set_level(1);\n}`); });

        // Monsters
        const monMap = {};
        rooms.forEach(r => r.monsters.forEach(m => {
            const parts = m.idName.split(',').map(s => s.trim());
            const primeId = parts[0].toLowerCase();
            const allIds = parts.map(s => `"${s.toLowerCase()}"`);
            allIds.push(`"${m.race.toLowerCase()}"`);
            const key = parts[0] + m.race;
            if(!monMap[key]) {
                const fname = makeSafe(parts[0]) + ".c";
                monMap[key] = fname;
                let gear = ""; m.inventory.forEach(id => { if(objMap[id]) gear += `    add_object(OBJDIR+"${objMap[id]}");\n`; });
                if(gear) gear += `    command("wear all");\n    command("wield all");`;
                let clsCode = (m.class && m.class.toLowerCase() !== "none") ? `    set_class("${m.class.toLowerCase()}");\n` : "";
                f.folder("mon").file(fname, `#include "../include/include.h"\ninherit MONSTER;\nvoid create() {\n    ::create();\n    set_name("${primeId}");\n    set_id(({${allIds.join(',')}}));\n${formatLPC("set_short", m.short)}\n${formatLPC("set_long", m.long)}\n    set_level(${getLevelStr(m.levelAdj)});\n    set_race("${m.race.toLowerCase()}");\n${clsCode}    set_gender("${m.gender}");\n    set_alignment(${m.alignment});\n${gear}\n}`);
            }
        }));

        // Rooms
        const rMap = {}; const names = {};
        rooms.forEach(r => { let n = makeSafe(r.name); names[n] = (names[n]||0) + 1; rMap[r.id] = (names[n]>1 ? `${n}_${names[n]}` : n) + ".c"; });

        rooms.forEach(r => {
            let ex = [], doors = [], mons = [], objs = [], looks = [], listens = [], smells = [];
            links.forEach(l => {
                let tr = null;
                if(l.from==r.id) tr=rooms.find(x=>x.id==l.to); else if(l.to==r.id) tr=rooms.find(x=>x.id==l.from);
                if(tr) {
                    let d="unknown";
                    if(tr.z>r.z)d="up"; else if(tr.z<r.z)d="down";
                    else if(tr.y<r.y) { if(tr.x<r.x)d="northwest"; else if(tr.x>r.x)d="northeast"; else d="north"; }
                    else if(tr.y>r.y) { if(tr.x<r.x)d="southwest"; else if(tr.x>r.x)d="southeast"; else d="south"; }
                    else { if(tr.x>r.x)d="east"; else if(tr.x<r.x)d="west"; }
                    ex.push(`        "${d}" : ROOMDIR+"${rMap[tr.id].replace('.c','')}"`);
                    if(l.door && l.door.active) {
                        let k = l.door.key ? `"${l.door.key}"` : "0";
                        let istate = (l.door.state === 'open') ? "ISTATE_OPEN" : (l.door.state === 'locked' ? "ISTATE_LOCKED" : "0");
                        doors.push(`    set_door("${l.door.id}", "${d}", ${k}${istate!=='0'?', 0, 0, '+istate:''});`);
                    }
                }
            });
            r.details.forEach(det => {
                let keys = det.keywords.split(',').map(k=>`"${k.trim()}"`).join(',');
                if(det.type === 'look') looks.push(`        ({${keys}}) : "${det.desc}"`);
                else if(det.type === 'listen') listens.push(`    set_listen(({${keys}}), "${det.desc}");`);
                else if(det.type === 'smell') smells.push(`    set_smell(({${keys}}), "${det.desc}");`);
            });
            r.monsters.forEach(m => { const parts = m.idName.split(',').map(s => s.trim()); mons.push(`    add_object(MONDIR+"${monMap[parts[0]+m.race]}", "", RT_TRACK);`); });
            r.objects.forEach(id => { if(objMap[id]) objs.push(`    add_object(OBJDIR+"${objMap[id]}", "", RT_TRACK);`); });

            let exCode = ex.length ? `    set_exits(([\n${ex.join(',\n')}\n    ]));` : "";
            let lookCode = looks.length ? `    set_items(([\n${looks.join(',\n')}\n    ]));` : "";
            let terrainCode = (r.terrain && r.terrain !== "indoor") ? `    set_terrain("${r.terrain}");\n` : "";
            let commentBlock = r.comments ? r.comments.split('\n').map(l=>`// ${l}`).join('\n') + "\n" : "";

            f.folder("rooms").file(rMap[r.id], `${commentBlock}#include "../include/include.h"\ninherit ROOM;\nvoid create() {\n    ::create();\n${formatLPC("set_short", r.name)}\n${formatLPC("set_long", r.longDesc)}\n${terrainCode}${lookCode}\n${listens.join('\n')}\n${smells.join('\n')}\n${exCode}\n${doors.join('\n')}\n${mons.join('\n')}\n${objs.join('\n')}\n}`);
        });

        // Docs
        f.folder("docs").file("map.txt", generateASCIIMap(rMap));

        // --- NEW: STATS FILE GENERATION ---
        const totalMonsters = rooms.reduce((acc, r) => acc + r.monsters.length, 0);
        const totalObjects = rooms.reduce((acc, r) => acc + r.objects.length, 0);
        
        const statsContent = `Project Statistics
==================
Area Name:  ${exportSettings.areaName}
Base Path:  ${exportSettings.basePath}
Base Level: ${exportSettings.baseLevel}

Counts
------
Total Rooms:        ${rooms.length}
Placed Monsters:    ${totalMonsters}
Placed Objects:     ${totalObjects}
Unique Object Defs: ${objectLibrary.length}
`;
        f.folder("docs").file("stats.txt", statsContent);
        // ----------------------------------

        saveAs(await zip.generateAsync({type:"blob"}), `${area}.zip`);
    }

    function downloadJSON() { saveAs(new Blob([JSON.stringify({ rooms, links, objectLibrary, exportSettings })],{type:'application/json'}), 'mud.json'); }
    function importData() { let i = document.createElement('input'); i.type='file'; i.onchange=e=>{ let r=new FileReader(); r.onload=ev=>{ let d=JSON.parse(ev.target.result); rooms=d.rooms; links=d.links; objectLibrary=d.objectLibrary||[]; exportSettings=d.exportSettings||exportSettings; activeRoom=rooms[0]; currentZ=activeRoom.z; document.getElementById('area-name').value = exportSettings.areaName; document.getElementById('base-path').value = exportSettings.basePath; document.getElementById('base-level').value = exportSettings.baseLevel; syncUI(); }; r.readAsText(e.target.files[0]); }; i.click(); }

    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", init); else init();
</script>
</body>
</html>